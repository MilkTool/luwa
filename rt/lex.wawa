func lxpush
len i32 ch i32 i32
ts i32 nl i32 l1 i32
	load len
	i32 1
	i32.add
	tee l1
	i32 4
	call nthtmp
	i32.load 5
	i32.eq
	if
		load len
		load len
		i32.add
		tee nl
		call newstr
		tee ts
		i32 4
		call nthtmp
		load len
		i32 13
		i32.add
		call memcpy8

		load ts
		load nl
		i32.store 5

		load ts
		i32 4
		call setnthtmp
	end
	i32 4
	call nthtmp
	load len
	i32.add
	load ch
	i32.store8 13

	load l1

func lxaddval
o i32 tmpid i32 len i32 i64
boxlen i32
	i32 3
	call nthtmp
	load o
	call tabget
	tee boxlen
	loadg onil
	i32.eq
	if i64
		load o
		call tmppush

		load len
		i64.extend_u/i32
		call newi64
		store boxlen
		i32 4
		call nthtmp
		load o
		load boxlen
		call tabset

		i32 1
		call nthtmp
		call tmppop
		load tmpid
		load len
		call pushvec
		i64.extend_u/i32
		load len
		i64.extend_u/i32
		i64 32
		i64.shl
		i64.or
	else
		load boxlen
		i64.load 5
		i64 32
		i64.shl
		load len
		i64.extend_u/i32
		i64.or
	end

;macro lxaddnum
;$temp i64
;	i32 1
;	load numlen
;	call lxaddval
;	tee $temp
;	i32.wrap/i64
;	store numlen
;	load $temp
;	i64 32
;	i64.shr_u
;	i32.wrap/i64

export func lex
src i32 i32
i i32 ch i32 lxlen i32 j i32 srclen i32 numlen i32 strlen i32 temp64 i64
	block @loopwrap
		load src
		i32.load 5
		store srclen

		; 5 src
		load src
		call tmppush

		; 4 lex
		i32 1011
		call newstr
		call tmppush

		; 3 reverse mapping of strs/nums
		call newtable
		call tmppush

		; 2 [strs]
		i32 256
		call newvec
		call tmppush

		; 1 [nums]
		i32 64
		call newvec
		call tmppush

		i32 5
		call nthtmp
		i32.load 5
		i32.eqz
		br_if 0

		loop @loopnoinc
			block @loop
				load i
				load srclen
				i32.eq
				br_if @loopwrap

				i32 5
				call nthtmp
				tee src
				load i
				i32.add
				i32.load8_u 13
				store ch

				block @invalid
				block @tilde
				block @rc
				block @pipe
				block @lc
				block @circum
				block @rs
				block @ls
				block @id
				block @gt
				block @eq
				block @lt
				block @semi
				block @colon
				block @digit
				block @dot
				block @solidus
				block @minus
				block @comma
				block @plus
				block @ast
				block @rp
				block @lp
				block @amp
				block @cent
				block @hash
				block @quote
				load ch
				i32 32
				i32.sub
				br_table @loop @invalid @quote @hash @invalid @cent @amp @quote @lp @rp @ast @plus @comma @minus @dot @solidus @digit @digit @digit @digit @digit @digit @digit @digit @digit @digit @colon @semi @lt @eq @gt @invalid @invalid @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @ls @invalid @rs @circum @id @invalid @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @lc @pipe @rc @tilde @invalid
				end ;@quote " '
				br @loop;;;
				end ;@hash #
				load lxlen
				i32 29
				call lxpush
				store lxlen
				br @loop
				end ;@cent %
				load lxlen
				i32 27
				call lxpush
				store lxlen
				br @loop
				end ;@amp &
				load lxlen
				i32 30
				call lxpush
				store lxlen
				br @loop
				end ;@lp (
				load lxlen
				i32 43
				call lxpush
				store lxlen
				br @loop
				end ;@rp )
				load lxlen
				i32 44
				call lxpush
				store lxlen
				br @loop
				end ;@ast *
				load lxlen
				i32 25
				call lxpush
				store lxlen
				br @loop
				end ;@plus +
				load lxlen
				i32 23
				call lxpush
				store lxlen
				br @loop
				end ;@comma ,
				load lxlen
				i32 52
				call lxpush
				store lxlen
				br @loop
				end ;@minus -
				load lxlen
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 24
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 45 ; '-
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						load srclen
						i32.eq
						br_if @loop

						load i
						i32 1
						i32.add
						load src
						i32.add
						i32.load8_u
						i32 91 ;'[
						i32.eq
						if @ifdeepcomm
							i32 0
							store ch
							block @deepcomm
							loop ; count =s
								; eof?
								load ch
								i32 1
								i32.add
								tee ch
								load i
								i32.add
								load srclen
								i32.eq
								br_if @loopnoinc

								; =?
								load ch
								load i
								i32.add
								load src
								i32.add
								i32.load8_u 13
								i32 61 ; '=
								i32.eq
								br_if 0

								; if [, scan, else enter newline scan
								load ch
								load i
								i32.add
								load src
								i32.add
								i32.load8_u 13
								i32 91 ; '[
								i32.eq
								br_table @ifdeepcomm @deepcomm
							end
							end

							loop ; scan for ]
								; eof?
								load i
								i32 1
								i32.add
								tee i
								load ch
								i32.add
								load srclen
								i32.eq
								br_if @loopnoinc

								; reloop if not ]
								load i
								load ch
								i32.add
								tee i
								load src
								i32.add
								i32.load8_u 13
								i32 93 ; ']
								i32.ne
								br_if 0

								; count =s
								load i
								store j
								loop i32
									; eof?
									load i
									i32 1
									i32.add
									tee i
									load ch
									i32.add
									load srclen
									i32.eq
									br_if @loopnoinc

									; =?
									load i
									load ch
									i32.add
									load src
									i32.add
									i32.load8_u 13
									i32 61
									i32.eq
									br_if 0

									load i
								end
								load j
								i32.sub
								load ch
								i32.ne
								br_if 0 ; reloop if wrong = count

								; eof?
								load i
								i32 1
								i32.add
								tee i
								load ch
								i32.add
								load srclen
								i32.eq
								br_if @loopnoinc

								; if not ], reloop
								load i
								load ch
								i32.add
								load src
								i32.add
								i32.load8_u 13
								i32 93 ; ']
								i32.ne
								br_if 0

								; end of comment. Increment i by ch & break
								load i
								load ch
								i32.add
								store i

								br @loop
							end
						end

						loop i32
							load i
							i32 1
							i32.add
							tee i
							load srclen
							i32.eq
							br_if @loopnoinc

							load i
							load src
							i32.add
							i32.load8_u 13
							i32 10
							i32.eq
							br_table 0 @loop
							i32 0 ; not needed?
						end
					else
						i32 24
					end
				end
				call lxpush
				store lxlen
				br @loop
				end ;@solidus /
				load lxlen
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 26
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 47 ; '/
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						i32 35
					else
						i32 26
					end
				end
				call lxpush
				store lxlen
				br @loop
				end ;@dot .
				load lxlen
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 53
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 46 ; '.
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						tee i
						load srclen
						i32.eq
						if i32
							i32 54
						else
							load i
							load src
							i32.add
							i32.load8_u 13
							i32 46 ; '.
							i32.eq
							if i32
								load i
								i32 1
								i32.add
								store i

								i32 55
							else
								i32 54
							end
						end
					else
						i32 53
					end
				end
				call lxpush
				store lxlen
				br @loop
				end ;@digit
				br @loop;;;
				end ;@colon :
				load lxlen
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 51
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 58 ; ':
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						i32 49
					else
						i32 51
					end
				end
				call lxpush
				store lxlen
				end ;@semi ;
				load lxlen
				i32 50
				call lxpush
				store lxlen
				br @loop
				end ;@lt <
				load lxlen
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32 @ltifelse
					i32 38
				else
					block
					block
					block
						load i
						load src
						i32.add
						i32.load8_u 13
						i32 61 ; '=
						i32.sub
						br_table 0 1 2
					end ; =
						load i
						i32 1
						i32.add
						store i

						i32 40 ; lte
						br @ltifelse
					end ; <
						load i
						i32 1
						i32.add
						store i

						i32 33 ; lsh
						br @ltifelse
					end ; default
					i32 38
				end
				call lxpush
				store lxlen
				br @loop
				end ;@eq =
				load lxlen
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 42
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 61 ; '=
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						i32 36
					else
						i32 42
					end
				end
				call lxpush
				store lxlen
				br @loopnoinc
				end ;@gt >
				load lxlen
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32 @gtifelse
					i32 39
				else
					block
					block
					block
						load i
						load src
						i32.add
						i32.load8_u 13
						i32 61 ; '=
						i32.sub
						br_table 0 2 1 2
					end ; =
						load i
						i32 1
						i32.add
						store i

						i32 41 ; gte
						br @gtifelse
					end ; >
						load i
						i32 1
						i32.add
						store i

						i32 34 ; rsh
						br @gtifelse
					end ; default
					i32 39
				end
				call lxpush
				store lxlen
				br @loop
				end ;@id A-Za-z_
				load i
				store j

				loop ; scan until not 0-9A-Z_a-z
					load i
					i32 1
					i32.add
					tee i
					load srclen 
					i32.eq
					br_if @loopnoinc

					load src
					load i
					i32.add
					i32.load8_u 13
					i32 48
					i32.sub
					tee ch
					i32 10
					i32.lt_u
					br_if 0

					load ch
					i32 17 ; 65-48 ('A - '0)
					i32.sub
					tee ch
					i32 26
					i32.lt_u
					br_if 0

					load ch
					i32 30 ; 95-65-48 ('_ - 'A - '0)
					i32.eq
					br_if 0

					load ch
					i32 32 97-65-48 ('a - 'A - '0)
					i32.sub
					i32 26
					i32.lt_u
					br_if 0
				end

				load i
				load j
				i32.sub
				tee ch
				call newstr
				tee src
				i32 13
				i32.add
				i32 4
				call nthtmp
				load j
				i32.add
				i32 13
				i32.add
				load ch
				call memcpy1rl

				load src
				i32 2
				load strlen
				call lxaddval
				tee temp64
				i32.wrap/i64
				store strlen
				load temp64
				i64 32
				i64.shr_u
				i32.wrap/i64
				store ch

				load lxlen
				i32 64
				call lxpush
				tee lxlen
				load ch
				call lxpush
				tee lxlen
				load ch
				i32 8
				i32.shr_u
				call lxpush
				tee lxlen
				load ch
				i32 16
				i32.shr_u
				call lxpush
				tee lxlen
				load ch
				i32 24
				i32.shr_u
				call lxpush
				store lxlen

				br @loop
				end ;@ls [
				load lxlen
				i32 47
				call lxpush
				store lxlen
				br @loop
				end ;@rs ]
				load lxlen
				i32 48
				call lxpush
				store lxlen
				br @loop
				end ;@circum ^
				load lxlen
				i32 28
				call lxpush
				store lxlen
				br @loop
				end ;@lc {
				load lxlen
				i32 45
				call lxpush
				store lxlen
				br @loop
				end ;@pipe |
				load lxlen
				i32 32
				call lxpush
				store lxlen
				br @loop
				end ;@rc }
				load lxlen
				i32 46
				call lxpush
				store lxlen
				br @loop
				end ;@tilde ~
				load lxlen
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 51
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 61 ; '=
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						i32 31
					else
						i32 51
					end
				end
				call lxpush
				store lxlen
				end ;@invalid
				unreachable ; TODO better error mechanism
			end
			load i
			i32 1
			i32.add
			store i
			br 0
		end
	end
	load lxlen
	i32 0
	call lxpush
	store lxlen

	load lxlen
	call newstr
	tee i
	i32 4
	call nthtmp
	load lxlen
	i32 13
	i32.add
	call allocsize
	call memcpy8
	load i
	load lxlen
	i32.store 5

	call tmppop
	call tmppop
	call tmppop
	call tmppop
	call tmppop
	load i

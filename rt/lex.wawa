func lxaddval
o i32 tmpid i32 len i32 i64
boxlen i32
	i32 3
	call nthtmp
	load o
	call tabget
	tee boxlen
	loadg onil
	i32.eq
	if i64
		load o
		call tmppush

		load len
		i64.extend_u/i32
		call newi64
		store boxlen
		i32 4
		call nthtmp
		load o
		load boxlen
		call tabset

		i32 1
		call nthtmp
		call tmppop
		load tmpid
		load len
		call pushvec
		i64.extend_u/i32
		load len
		i64.extend_u/i32
		i64 32
		i64.shl
		i64.or
	else
		load boxlen
		i64.load 5
		i64 32
		i64.shl
		load len
		i64.extend_u/i32
		i64.or
	end

;macro lxaddnum
;$temp i64
;	i32 1
;	load numlen
;	call lxaddval
;	tee $temp
;	i32.wrap/i64
;	store numlen
;	load $temp
;	i64 32
;	i64.shr_u
;	i32.wrap/i64

export func lex
src i32 void
i i32 ch i32 lxlen i32 j i32 k i32 srclen i32 numlen i32 strlen i32 tlen i32 temp64 i64
	block @loopwrap
		load src
		i32.load 5
		store srclen

		; TODO move src+revmap to top of stack so we can efficiently pop without popping other 3
		; 5 src
		load src
		call tmppush

		; 4 lex
		i32 1011
		call newstr
		call tmppush

		; 3 reverse mapping of strs/nums
		call newtable
		call tmppush

		; 2 [strs]
		i32 256
		call newvec
		call tmppush

		; 1 [nums]
		i32 64
		call newvec
		call tmppush

		i32 5
		call nthtmp
		i32.load 5
		i32.eqz
		br_if 0

		loop @loopnoinc
			block @loop
				load i
				load srclen
				i32.eq
				br_if @loopwrap

				i32 5
				call nthtmp
				tee src
				load i
				i32.add
				i32.load8_u 13
				store ch

				block @invalid
				block @tilde
				block @rc
				block @pipe
				block @lc
				block @circum
				block @rs
				block @ls
				block @id
				block @gt
				block @eq
				block @lt
				block @semi
				block @colon
				block @digit
				block @dot
				block @solidus
				block @minus
				block @comma
				block @plus
				block @ast
				block @rp
				block @lp
				block @amp
				block @cent
				block @hash
				block @quote
				load ch
				i32 32
				i32.sub
				br_table @loop @invalid @quote @hash @invalid @cent @amp @quote @lp @rp @ast @plus @comma @minus @dot @solidus @digit @digit @digit @digit @digit @digit @digit @digit @digit @digit @colon @semi @lt @eq @gt @invalid @invalid @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @ls @invalid @rs @circum @id @invalid @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @lc @pipe @rc @tilde @invalid
				end ;@quote " '
				i32 11
				call newstr
				call tmppush

				i32 0
				store tlen

				block @blockscanq
				loop @loopscanq
					load i
					i32 1
					i32.add
					tee i
					load srclen
					i32.eq
					br_if 1

					load i
					load src
					i32.add
					i32.load8_u 13
					tee j
					load ch
					i32.eq
					br_if 1

					load j
					i32 92
					i32.eq
					if i32 @stresc
						i32 0
						load i
						i32 1
						i32.add
						tee i
						load srclen
						i32.eq
						br_if @stresc
						drop

						load i
						load src
						i32.add
						i32.load8_u 13
						tee j
						i32 34
						i32.eq
						load j
						i32 34
						i32.eq
						i32.or
						load j
						i32 92
						i32.eq
						i32.or
						if i32
							load j
						else
							load j
							i32 48
							i32.sub
							tee j
							i32 10
							i32.lt_u
							if i32 @tblbr
								i32 0
								load i
								i32 1
								i32.add
								tee i
								load srclen
								i32.eq
								br_if @stresc
								drop

								load i
								load src
								i32.add
								i32.load8_u 13
								i32 48
								i32.sub
								tee ch
								i32 10
								i32.lt_u
								if i32
									i32 0
									load i
									i32 1
									i32.add
									tee i
									load srclen
									i32.eq
									br_if @stresc
									drop

									load i
									load src
									i32.add
									i32.load8_u 13
									i32 47
									i32.sub
									tee k
									i32 10
									i32.lt_u
									if i32
										load j
										i32 100
										i32.mul
										load ch
										i32 10
										i32.mul
										i32.add
										load k
										i32.add
									else
										load i
										i32 1
										i32.sub
										store i

										load j
										i32 10
										i32.mul
										load ch
										i32.add
									end
								else
									load i
									i32 1
									i32.sub
									store i

									load j
								end
							else
								block @a
								block @b
								block @f
								block @n
								block @r
								block @t
								block @u
								block @v
								block @x
								block @noesc
									load j
									i32 49
									i32.sub
									br_table @a @b @noesc @noesc @noesc @f @noesc @noesc @noesc @noesc @noesc @noesc @noesc @n @noesc @noesc @noesc @r @noesc @t @u @v @noesc @x @noesc
								end 'noesc
									unreachable
									br @tblbr
								end 'x
									; TODO update lexer to use ge not eq
									; then do i+=2, not i+=1 i+=1
									i32 0
									load i
									i32 1
									i32.add
									tee i
									load srclen
									i32.eq
									br_if @stresc
									drop

									i32 0
									load i
									i32 1
									i32.add
									tee i
									load srclen
									i32.eq
									br_if @stresc
									drop

									load i
									i32 1
									i32.sub
									load src
									i32.add
									i32.load8_u 13
									call chex
									i32 16
									i32.mul

									load i
									load src
									i32.add
									i32.load8_u 13
									call chex
									i32.add
									br @tblbr
								end 'v
									i32 11
									br @tblbr
								end 'u
									unreachable
									br @loopscanq
								end 't
									i32 9
									br @tblbr
								end 'r
									i32 13
									br @tblbr
								end 'n
									i32 10
									br @tblbr
								end 'f
									i32 12
									br @tblbr
								end 'b
									i32 8
									br @tblbr
								end 'a
									i32 7
							end
						end
					else
						load j
					end

					i32 1
					load tlen
					call pushstr
					store tlen
					br 0
				end
				end

				load tlen
				call newstr
				tee ch
				i32 13
				i32.add
				i32 1
				call nthtmp
				i32 13
				i32.add
				load ch
				i32.load 5
				call memcpy1rl
				call tmppop

				load ch
				i32 2
				load strlen
				call lxaddval
				tee temp64
				i32.wrap/i64
				store strlen
				load temp64
				i64 32
				i64.shr_u
				i32.wrap/i64
				store ch

				load ch
				i32 24
				i32.shr_u
				i32 4

				load ch
				i32 16
				i32.shr_u
				i32 4

				load ch
				i32 8
				i32.shr_u
				i32 4

				load ch
				i32 4

				i32 128
				i32 4
				load lxlen
				call pushstr
				call pushstr
				call pushstr
				call pushstr
				call pushstr
				store lxlen

				br @loop
				end ;@hash #
				i32 29
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@cent %
				i32 27
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@amp &
				i32 30
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@lp (
				i32 43
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@rp )
				i32 44
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@ast *
				i32 25
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@plus +
				i32 23
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@comma ,
				i32 52
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@minus -
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 24
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 45 ; '-
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						load srclen
						i32.eq
						br_if @loop

						load i
						i32 1
						i32.add
						load src
						i32.add
						i32.load8_u
						i32 91 ;'[
						i32.eq
						if @ifdeepcomm
							i32 0
							store ch
							block @deepcomm
							loop ; count =s
								; eof?
								load ch
								i32 1
								i32.add
								tee ch
								load i
								i32.add
								load srclen
								i32.eq
								br_if @loopnoinc

								; =?
								load ch
								load i
								i32.add
								load src
								i32.add
								i32.load8_u 13
								i32 61 ; '=
								i32.eq
								br_if 0

								; if [, scan, else enter newline scan
								load ch
								load i
								i32.add
								load src
								i32.add
								i32.load8_u 13
								i32 91 ; '[
								i32.eq
								br_table @ifdeepcomm @deepcomm
							end
							end

							loop ; scan for ]
								; eof?
								load i
								i32 1
								i32.add
								tee i
								load ch
								i32.add
								load srclen
								i32.eq
								br_if @loopnoinc

								; reloop if not ]
								load i
								load ch
								i32.add
								tee i
								load src
								i32.add
								i32.load8_u 13
								i32 93 ; ']
								i32.ne
								br_if 0

								; count =s
								load i
								store j
								loop i32
									; eof?
									load i
									i32 1
									i32.add
									tee i
									load ch
									i32.add
									load srclen
									i32.eq
									br_if @loopnoinc

									; =?
									load i
									load ch
									i32.add
									load src
									i32.add
									i32.load8_u 13
									i32 61
									i32.eq
									br_if 0

									load i
								end
								load j
								i32.sub
								load ch
								i32.ne
								br_if 0 ; reloop if wrong = count

								; eof?
								load i
								i32 1
								i32.add
								tee i
								load ch
								i32.add
								load srclen
								i32.eq
								br_if @loopnoinc

								; if not ], reloop
								load i
								load ch
								i32.add
								load src
								i32.add
								i32.load8_u 13
								i32 93 ; ']
								i32.ne
								br_if 0

								; end of comment. Increment i by ch & break
								load i
								load ch
								i32.add
								store i

								br @loop
							end
						end

						loop i32
							load i
							i32 1
							i32.add
							tee i
							load srclen
							i32.eq
							br_if @loopnoinc

							load i
							load src
							i32.add
							i32.load8_u 13
							i32 10
							i32.eq
							br_table 0 @loop
							i32 0 ; not needed?
						end
					else
						i32 24
					end
				end
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@solidus /
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 26
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 47 ; '/
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						i32 35
					else
						i32 26
					end
				end
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@dot .
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 53
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 46 ; '.
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						tee i
						load srclen
						i32.eq
						if i32
							i32 54
						else
							load i
							load src
							i32.add
							i32.load8_u 13
							i32 46 ; '.
							i32.eq
							if i32
								load i
								i32 1
								i32.add
								store i

								i32 55
							else
								i32 54
							end
						end
					else
						i32 53
					end
				end
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@digit
				br @loop;;;
				end ;@colon :
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 51
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 58 ; ':
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						i32 49
					else
						i32 51
					end
				end
				i32 4
				load lxlen
				call pushstr
				store lxlen
				end ;@semi ;
				i32 50
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@lt <
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32 @ltifelse
					i32 38
				else
					block
					block
					block
						load i
						load src
						i32.add
						i32.load8_u 13
						i32 61 ; '=
						i32.sub
						br_table 0 1 2
					end ; =
						load i
						i32 1
						i32.add
						store i

						i32 40 ; lte
						br @ltifelse
					end ; <
						load i
						i32 1
						i32.add
						store i

						i32 33 ; lsh
						br @ltifelse
					end ; default
					i32 38
				end
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@eq =
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 42
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 61 ; '=
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						i32 36
					else
						i32 42
					end
				end
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loopnoinc
				end ;@gt >
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32 @gtifelse
					i32 39
				else
					block
					block
					block
						load i
						load src
						i32.add
						i32.load8_u 13
						i32 61 ; '=
						i32.sub
						br_table 0 2 1 2
					end ; =
						load i
						i32 1
						i32.add
						store i

						i32 41 ; gte
						br @gtifelse
					end ; >
						load i
						i32 1
						i32.add
						store i

						i32 34 ; rsh
						br @gtifelse
					end ; default
					i32 39
				end
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@id A-Za-z_
				load i
				store j

				loop ; scan until not 0-9A-Z_a-z
					load i
					i32 1
					i32.add
					tee i
					load srclen 
					i32.eq
					br_if @loopnoinc

					load src
					load i
					i32.add
					i32.load8_u 13
					i32 48
					i32.sub
					tee ch
					i32 10
					i32.lt_u
					br_if 0

					load ch
					i32 17 ; 65-48 ('A - '0)
					i32.sub
					tee ch
					i32 26
					i32.lt_u
					br_if 0

					load ch
					i32 30 ; 95-65-48 ('_ - 'A - '0)
					i32.eq
					br_if 0

					load ch
					i32 32 ; 97-65-48 ('a - 'A - '0)
					i32.sub
					i32 26
					i32.lt_u
					br_if 0
				end

				load i
				load j
				i32.sub
				tee ch
				call newstr
				tee src
				i32 13
				i32.add
				i32 5
				call nthtmp
				load j
				i32.add
				i32 13
				i32.add
				load ch
				call memcpy1rl

				load src
				i32 2
				load strlen
				call lxaddval
				tee temp64
				i32.wrap/i64
				store strlen
				load temp64
				i64 32
				i64.shr_u
				i32.wrap/i64
				store ch

				load ch
				i32 24
				i32.shr_u
				i32 4

				load ch
				i32 16
				i32.shr_u
				i32 4

				load ch
				i32 8
				i32.shr_u
				i32 4

				load ch
				i32 4

				i32 64
				i32 4
				load lxlen
				call pushstr
				call pushstr
				call pushstr
				call pushstr
				call pushstr
				store lxlen

				br @loop
				end ;@ls [
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32 @lsvalif
					i32 47
				else
					; TODO nested strings, omit opening character being newline
					i32 0
					store tlen
					load i
					i32 1
					i32.sub
					store j

					loop i32 @lscounteq
						i32 47
						load j
						i32 1
						i32.add
						tee j
						load srclen
						i32.eq
						br_if @lsvalif
						drop

						load j
						load src
						i32.add
						i32.load8_u 13
						tee ch
						i32 61 ; '=
						i32.eq
						if i32
							load tlen
							i32 1
							i32.add
							store tlen
							br @lscounteq
						else
							i32 47
							load ch
							i32 91 ; '[
							i32.ne
							br_if @lsvalif
							drop

							loop i32 @lsseekeq
								i32 47
								load j
								i32 1
								i32.add
								tee j
								load srclen
								i32.eq
								br_if @lsvalif
								drop

								load j
								load src
								i32.add
								i32.load8_u 13
								i32 93 ; ']
								i32.ne
								br_if 0

								load j
								store ch
								block
								loop
									load j
									load ch
									i32.sub
									load tlen
									i32.eq
									br_if 1

									i32 47
									load j
									i32 1
									i32.add
									tee j
									load srclen
									i32.eq
									br_if @lsvalif
									drop

									load j
									load src
									i32.add
									i32.load8_u 13
									i32 61
									i32.ne
									br_if @lsseekeq
									br 0
								end
								end

								i32 47
								load j
								i32 1
								i32.add
								tee j
								load srclen
								i32.eq
								br_if @lsvalif
								drop

								load j
								load src
								i32.add
								i32.load8_u 13
								i32 93
								i32.ne
								br_if @lsseekeq

								; i, ch, tlen = j+1, i + 1 + tlen + 13, ch - i - tlen - 1
								load ch
								load i
								i32.sub
								load tlen
								i32.sub
								i32 1
								i32.sub

								load i
								load tlen
								i32.add
								i32 14
								i32.add

								load j
								i32 1
								i32.add

								store i
								store ch
								tee tlen

								call newstr
								tee src
								i32 13
								i32.add
								i32 5
								call nthtmp
								load ch
								i32.add
								load tlen
								call memcpy1rl

								load src
								i32 2
								load strlen
								call lxaddval
								tee temp64
								i32.wrap/i64
								store strlen
								load temp64
								i64 32
								i64.shr_u
								i32.wrap/i64
								store ch

								load ch
								i32 24
								i32.shr_u
								i32 4

								load ch
								i32 16
								i32.shr_u
								i32 4

								load ch
								i32 8
								i32.shr_u
								i32 4

								load ch
								i32 4

								i32 128
								i32 4
								load lxlen
								call pushstr
								call pushstr
								call pushstr
								call pushstr
								call pushstr
								store lxlen

								load j
								i32 1
								i32.add
								store i
								br @loopnoinc
							end
						end
					end
				end
				i32 4
				load lxlen
				call pushstr
				store lxlen

				br @loopnoinc
				end ;@rs ]
				i32 48
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@circum ^
				i32 28
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@lc {
				i32 45
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@pipe |
				i32 32
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@rc }
				i32 46
				i32 4
				load lxlen
				call pushstr
				store lxlen
				br @loop
				end ;@tilde ~
				load i
				i32 1
				i32.add
				tee i
				load srclen
				i32.eq
				if i32
					i32 51
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 61 ; '=
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						i32 31
					else
						i32 51
					end
				end
				i32 4
				load lxlen
				call pushstr
				store lxlen
				end ;@invalid
				unreachable ; TODO better error mechanism
			end
			load i
			i32 1
			i32.add
			store i
			br 0
		end
	end
	i32 0
	i32 4
	load lxlen
	call pushstr
	store lxlen

	load lxlen
	call newstr
	tee i
	i32 4
	call nthtmp
	load lxlen
	i32 13
	i32.add
	call allocsize
	call memcpy8
	load i
	load lxlen
	i32.store 5

	load i
	i32 2
	call nthtmp
	i32 1
	call nthtmp
	call tmppop
	call tmppop
	i32 1
	call setnthtmp
	i32 2
	call setnthtmp
	i32 3
	call setnthtmp


func lxpush
len i32 ch i32 i32
ts i32 nl i32
	load len
	i32 1
	i32.add
	i32 4
	call nthtmp
	i32.load 5
	i32.eq
	if
		load len
		load len
		i32.add
		tee nl
		call newstr
		tee ts
		i32 4
		call nthtmp
		load len
		i32 13
		i32.add
		call memcpy8

		load ts
		load nl
		i32.store 5
	end
	i32 4
	call nthtmp
	load len
	i32.add
	load ch
	i32.store8

	load len
	i32 1
	i32.add

export func lex
src i32 i32
i i32 ch i32 slen i32 j i32
	block @loopwrap
		; 5 src
		load src
		call tmppush

		; 4 lex
		i32 1011
		call newstr
		call tmppush

		; 3 reverse mapping of idents/nums
		call newtable
		call tmppush

		; 2 idents - array
		call newtable
		call tmppush

		; 1 nums - array
		call newtable
		call tmppush

		i32 5
		call nthtmp
		i32.load 5
		i32.eqz
		br_if 0

		loop @loopnoinc
			block @loop
				i32 5
				call nthtmp
				tee src
				i32.load 5
				load i
				i32.eq
				br_if @loopwrap

				load src
				load i
				i32.add
				i32.load8_u 13
				store ch

				block @invalid
				block @tilde
				block @rc
				block @pipe
				block @lc
				block @circum
				block @rs
				block @ls
				block @id
				block @gt
				block @eq
				block @lt
				block @semi
				block @colon
				block @digit
				block @dot
				block @solidus
				block @minus
				block @comma
				block @plus
				block @ast
				block @rp
				block @lp
				block @amp
				block @cent
				block @hash
				block @quote
				load ch
				i32 32
				i32.sub
				br_table @loop @invalid @quote @hash @invalid @cent @amp @quote @lp @rp @ast @plus @comma @minus @dot @solidus @digit @digit @digit @digit @digit @digit @digit @digit @digit @digit @colon @semi @lt @eq @gt @invalid @invalid @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @ls @invalid @rs @circum @id @invalid @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @id @lc @pipe @rc @tilde @invalid
				end ;@quote " '
				;;;
				end ;@hash #
				load slen
				i32 29
				call lxpush
				store slen
				br @loop
				end ;@cent %
				load slen
				i32 27
				call lxpush
				store slen
				br @loop
				end ;@amp &
				load slen
				i32 30
				call lxpush
				store slen
				br @loop
				end ;@lp (
				load slen
				i32 43
				call lxpush
				store slen
				br @loop
				end ;@rp )
				load slen
				i32 44
				call lxpush
				store slen
				br @loop
				end ;@ast *
				load slen
				i32 25
				call lxpush
				store slen
				br @loop
				end ;@plus +
				load slen
				i32 23
				call lxpush
				store slen
				br @loop
				end ;@comma ,
				load slen
				i32 52
				call lxpush
				store slen
				br @loop
				end ;@minus -
				load slen
				load i
				i32 1
				i32.add
				tee i
				load slen
				i32.eq
				if i32
					load 24
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 45 ; '-
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						load slen
						i32.eq
						br_if @loop

						load i
						i32 1
						i32.add
						load src
						i32.add
						i32.load8_u
						i32 91 ;'[
						i32.eq
						if @ifdeepcomm
							i32 0
							store ch
							block @deepcomm
							loop ; count =s
								; eof?
								load ch
								i32 1
								i32.add
								tee ch
								load i
								i32.add
								load slen
								i32.eq
								br_if @loopnoinc

								; =?
								load ch
								load i
								i32.add
								load src
								i32.add
								i32.load8_u 13
								i32 61 ; '=
								i32.eq
								br_if 0

								; if [, scan, else enter newline scan
								load ch
								load i
								i32.add
								load src
								i32.add
								i32.load8_u 13
								i32 91 ; '[
								i32.eq
								br_table @ifdeepcomm @deepcomm
							end
							end

							loop ; scan for ]
								; eof?
								load i
								i32 1
								i32.add
								tee i
								load ch
								i32.add
								load slen
								i32.eq
								br_if @loopnoinc

								; reloop if not ]
								load i
								load ch
								i32.add
								tee i
								load src
								i32.add
								i32.load8_u 13
								i32 93 ; ']
								i32.ne
								br_if 0

								; count =s
								load i
								store j
								loop i32
									; eof?
									load i
									i32 1
									i32.add
									tee i
									load ch
									i32.add
									load slen
									i32.eq
									br_if @loopnoinc

									; =?
									load i
									load ch
									i32.add
									load src
									i32.add
									i32.load8_u 13
									i32 61
									i32.eq
									br_if 0

									load i
								end
								load j
								i32.sub
								load ch
								i32.ne
								br_if 0 ; reloop if wrong = count

								; eof?
								load i
								i32 1
								i32.add
								tee i
								load ch
								i32.add
								load slen
								i32.eq
								br_if @loopnoinc

								; if not ], reloop
								load i
								load ch
								i32.add
								load src
								i32.add
								i32.load8_u 13
								i32 93 ; ']
								i32.ne
								br_if 0

								; end of comment. Increment i by ch & break
								load i
								load ch
								i32.add
								store i

								br @loop
							end
						end

						loop i32
							load i
							i32 1
							i32.add
							tee i
							load slen
							i32.eq
							br_if @loopnoinc

							load i
							load src
							i32.add
							i32.load8_u 13
							i32 10
							i32.eq
							br_table 0 @loop
							i32 0 ; not needed?
						end
					else
						load 24
					end
				end
				call lxpush
				store slen
				br @loop
				end ;@solidus /
				load slen
				load i
				i32 1
				i32.add
				tee i
				load slen
				i32.eq
				if i32
					load 26
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 47 ; '/
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						load 35
					else
						load 26
					end
				end
				call lxpush
				store slen
				br @loop
				end ;@dot .
				load slen
				load i
				i32 1
				i32.add
				tee i
				load slen
				i32.eq
				if i32
					load 53
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 46 ; '.
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						tee i
						load slen
						i32.eq
						if i32
							load 54
						else
							load i
							load src
							i32.add
							i32.load8_u 13
							i32 46 ; '.
							i32.eq
							if i32
								load i
								i32 1
								i32.add
								store i

								load 55
							else
								load 54
							end
						end
					else
						load 53
					end
				end
				call lxpush
				store slen
				br @loop
				end ;@digit
				;;;
				end ;@colon :
				load slen
				load i
				i32 1
				i32.add
				tee i
				load slen
				i32.eq
				if i32
					load 51
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 58 ; ':
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						load 49
					else
						load 51
					end
				end
				call lxpush
				store slen
				end ;@semi ;
				load slen
				i32 50
				call lxpush
				store slen
				br @loop
				end ;@lt <
				load slen
				load i
				i32 1
				i32.add
				tee i
				load slen
				i32.eq
				if i32 @ltifelse
					load 38
				else
					block
					block
					block
						load i
						load src
						i32.add
						i32.load8_u 13
						i32 61 ; '=
						i32.sub
						br_table 0 1 2
					end ; =
						load i
						i32 1
						i32.add
						store i

						load 40 ; lte
						br @ltifelse
					end ; <
						load i
						i32 1
						i32.add
						store i

						load 33 ; lsh
						br @ltifelse
					end ; default
					load 38
				end
				call lxpush
				store slen
				br @loop
				end ;@eq =
				load slen
				load i
				i32 1
				i32.add
				tee i
				load slen
				i32.eq
				if i32
					load 42
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 61 ; '=
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						load 36
					else
						load 42
					end
				end
				call lxpush
				store slen
				br @noloopinc
				end ;@gt >
				load slen
				load i
				i32 1
				i32.add
				tee i
				load slen
				i32.eq
				if i32 @gtifelse
					load 39
				else
					block
					block
					block
						load i
						load src
						i32.add
						i32.load8_u 13
						i32 61 ; '=
						i32.sub
						br_table 0 2 1 2
					end ; =
						load i
						i32 1
						i32.add
						store i

						load 41 ; gte
						br @gtifelse
					end ; >
						load i
						i32 1
						i32.add
						store i

						load 34 ; rsh
						br @gtifelse
					end ; default
					load 39
				end
				call lxpush
				store slen
				br @loop
				end ;@id A-Za-z_
				end ;@ls [
				load slen
				i32 47
				call lxpush
				store slen
				br @loop
				end ;@rs ]
				load slen
				i32 48
				call lxpush
				store slen
				br @loop
				end ;@circum ^
				load slen
				i32 28
				call lxpush
				store slen
				br @loop
				end ;@lc {
				load slen
				i32 45
				call lxpush
				store slen
				br @loop
				end ;@pipe |
				load slen
				i32 32
				call lxpush
				store slen
				br @loop
				end ;@rc }
				load slen
				i32 46
				call lxpush
				store slen
				br @loop
				end ;@tilde ~
				load slen
				load i
				i32 1
				i32.add
				tee i
				load slen
				i32.eq
				if i32
					load 51
				else
					load i
					load src
					i32.add
					i32.load8_u 13
					i32 61 ; '=
					i32.eq
					if i32
						load i
						i32 1
						i32.add
						store i

						load 31
					else
						load 51
					end
				end
				call lxpush
				store slen
				end ;@invalid
				unreachable ; TODO better error mechanism
			end
			load i
			i32 1
			i32.add
			store i
			br 0
		end
	end
	load slen
	i32 0
	call lxpush
	drop ; want to return length too

	i32 4
	call nthtmp
	call tmppop
	call tmppop
	call tmppop
	call tmppop
	call tmppop

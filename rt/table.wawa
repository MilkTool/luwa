use alloc

/*
struct Hkv {
	obj*key
	obj*val
}

struct Table {
	00 i32 ref
	04 i8 type
	05 i32 len
	09 i32 kappa
	13 i32 hlen
	17 i32 hcap
	21 obj*arr
	25 Hkv*hash
	29 Table*meta
}
*/

const sizeofHkv 8
const sizeofTable 34

func hash
o i32 i32
	block
	block
	block
	block
	block
	block
	load o
	i32.load8_u 4
	br_table 0 1 2 3 4 5
	end ;0 i64
	load o
	i32.load 5
	load o
	i32.load 9
	i32.xor
	ret
	end ;1 f64 TODO H(1.0) == H(1)
	load o
	i32.load 5
	load o
	i32 load 9
	i32.xor
	ret
	end ;2 nil
	load o
	ret
	end ;3 bool
	load o
	ret
	end ;4 table
	load o
	ret
	end ; 5 string
	load o
	i32.load 5
	ret

func mktable
i32
p i32 h i32
	i32 sizeofTable
	call malloc
	tee p
	i32 1
	i32.store
	load p
	i32 4
	i32.store8 4

	load p ;len,kappa = 0
	i64 0
	i64.store 5

	load p ; hlen,hcap = 0
	i64 0
	i64.store 13

	load p ; arr,hash = 0
	i64 0
	i64.store 21
	load p

	load p ; hash = malloc(4)
	i32 4
	call malloc
	tee h
	i32.store 25

	load h
	loadg onil
	i32.store 0

	load h
	i32 0
	i32.store 4

	load h
	loadg onil
	i32.store 8

	load h
	i32 0
	i32.store 12

	load h
	loadg onil
	i32.store 16

	load h
	i32 0
	i32.store 20

	load h
	loadg onil
	i32.store 24

	load h
	i32 0
	i32.store 28

	load p ; hcap = 4. TODO constant fold into hlen/hcap assign
	i32 4
	i32.store 17

	loadg onil ; meta = nil
	i32.store 29
	load p
	ret

func tabset
tab i32 key i32 val i32 void
kv i32 mx i32 rh i32
	load key
	cal hash

	;H <- H%cap(T)
	load tab
	i32.load 17
	i32.rem

	; H <- H*8
	i32 3
	i32.shl

	; kv = tab.hash[H]
	load tab
	i32.load 25
	i32.add
	store kv

	load tab
	i32.load 17
	i32 3
	i32.shl
	load tab
	i32.load 25
	i32.add
	store mx

	loop
		; if kv.key == nil { if kv.val = onil skip tombstone else if key != nil set }
		load kv
		i32.load
		loadg onil
		i32.eq
		if
			load kv
			i32.load 4
			loadg onil
			i32.ne
			load key
			loadg onil
			i32.ne
			i32.and
			if
				load kv
				load key
				i32.store 4

				; increment hlen, maybe rehash
				load tab
				i32.load 13
				i32 1
				i32.add
				tee mx
				i32.store 13
				load mx
				load mx
				i32.add
				load tab
				i32.load 17
				tee kv
				i32.gt_u
				if ; if hlen > hcap
					; allocate new table, store to tab
					load tab
					i32.load 25
					store val

					; weaved computation of new field values
					load tab
					load tab
					i32.load 25
					load kv
					tee mx
					load kv
					i32.add

					tee kv
					load tab
					load kv
					i32.store 17

					i32 3
					i32.shl
					tee kv
					call malloc
					tee key
					i32.store 25

					load tab
					i32 0
					i32.store 13

					loop
						load key
						load rh
						i32.add
						loadg onil
						i32.store

						load key
						load rh
						i32.add
						i32 0
						i32.store 4

						load rh
						i32 8
						i32.add
						tee rh
						load kv
						i32.eq
						if
							br 1
						end
					end
					i32 0
					store rh

					load mx
					i32 3
					i32.shl
					store mx

					; rehash. mx is oldhcap*8, val is oldhash
					loop
						; if val[rh].key != nil, tabset(tab, val[rh].key, val[rh].val)
						load rh
						load val
						i32.add
						tee kv
						i32.load
						loadg onil
						i32.ne
						if
							load tab
							load kv
							i32.load
							load kv
							i32.load 4
							call tabset
						end

						load rh
						i32 8
						i32.add
						tee rh
						load mx
						i32.eq
						if
							ret
						end
					end
				end
				ret
			end
		else
			; if kv.key = key, set, if val = nil, kv.key <- nil
			load kv
			i32.load
			load key
			call eq
			if
				load val
				loadg onil
				i32.eq
				if
					load kv
					loadg onil
					i32.store
				end
				load kv
				i32.load 4
				call decref
				load kv
				load val
				i32.store 4
				ret
			end

			; kv += 8, if kv == mx, kv = 0
			load kv
			i32 8
			i32.add
			tee kv
			load mx
			i32.eq
			if
				i32 0
				store kv
			end
		end
	end

func tabget
tab i32 key i32 i32
kv i32 mx i32
	load key
	call hash

	; H <- H%cap(T)
	load tab
	i32.load 17
	i32.rem

	; H <- H*8
	i32 3
	i32.shl

	; kv = tab.hash[H]
	load tab
	i32.load 25
	i32.add
	store kv

	load tab
	i32.load 17
	i32 3
	i32.shl
	load tab
	i32.load 25
	i32.add
	store mx

	loop
		; if kv.key == nil { if kv.val == onil skip tombstone else ret nil }
		load kv
		i32.load
		loadg onil
		i32.eq
		if
			load kv
			i32.load 4
			loadg onil
			i32.ne
			if
				loadg onil
				call incref
				ret
			end
		else
			; if kv.key == key, ret val
			load kv
			i32.load
			load key
			call eq
			if
				load kv
				i32.load 4
				call incref
				ret
			end

			; kv += 8, if kv == mx, kv = 0
			load kv
			i32 8
			i32.add
			tee kv
			load mx
			i32.eq
			if
				i32 0
				store kv
			end
		end
	end

/*
Decref children
*/
func freetable
x i32 void
	load x
	call free 

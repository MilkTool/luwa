func gccollect
void
freetip i32 livetip i32 sz i32 n i32 m i32
	loadg markbit
	i32.eqz
	storeg markbit

	; Phase0 marking phase
	loadg onil
	call gcmark
	loadg ofalse
	call gcmark
	loadg otrue
	call gcmark
	loadg otmp
	call gcmark
	loadg otmpstack
	call gcmark

	call .gcmark

	; Phase1 set reloc pointers
	loadg markbit
	store freetip

	loop
		load livetip
		call sizeof
		store sz

		load livetip
		i32.load
		loadg markbit
		i32.eq
		if
			load livetip
			load freetip
			i32.store

			load freetip
			load sz
			i32.add
			store freetip
		end

		load livetip
		load sz
		i32.add
		tee livetip
		loadg heaptip
		i32.ne
		br_if 0
	end

	; Phase2 fix reloc pointers
	loadg otmp
	i32.load
	i32 -8
	i32.and
	storeg otmp

	loadg otmpstack
	i32.load
	i32 -8
	i32.and
	storeg otmpstack

	i32 0
	store livetip
	loop
		load livetip
		call sizeof 
		store sz

		load livetip
		i32.load
		i32 1
		i32.and
		loadg markbit
		i32.eq
		if @terminal
			block @vec
			block @table
				load livetip
				i32.load8_u 4
				br_table @terminal @terminal @terminal @terminal @table @terminal @vec
			end ; @table
			load livetip
			load livetip
			i32.load 13
			i32.load
			i32 -8
			i32.and
			i32.store 13
			load livetip
			load livetip
			i32.load 17
			i32.load
			i32 -8
			i32.and
			i32.store 17
			load livetip
			load livetip
			i32.load 21
			i32.load
			i32 -8
			i32.and
			i32.store 21
			end ; @vec
			load livetip
			tee n
			load livetip
			i32.load 5
			i32.add
			store m
			loop
				load n
				load m
				i32.eq
				br_if 1

				load n
				load n
				i32.load 9
				i32.load
				i32 -8
				i32.and
				i32.store 9

				load n
				i32 4
				i32.add
				store n

				br 0
			end
		end

		load livetip
		load sz
		i32.add
		tee livetip
		loadg heaptip
		i32.ne
		br_if 0
	end

	call .gcfix

	; Phase3 move it
	i32 0
	store livetip
	block
		block @foundshift
		loop
			load livetip
			call sizeof
			store sz

			load livetip
			i32.load
			i32 1
			i32.and
			loadg markbit
			i32.eq
			if
				load livetip
				load livetip
				i32.load
				i32 -8
				i32.and
				tee n
				i32.ne
				br_if @foundshift
			end

			load livetip
			load sz
			i32.add
			tee livetip
			loadg heaptip
			i32.eq
			br_table 0 2
		end
		end

		load n
		load livetip
		load sz
		call memcpy8

		load livetip
		load sz
		i32.add
		tee livetip
		loadg heaptip
		i32.ne
		if
			loop
				load livetip
				call sizeof
				store sz

				load livetip
				i32.load
				i32 1
				i32.and
				loadg markbit
				i32.eq
				if
					load livetip
					i32.load
					i32 -8
					i32.and
					load livetip
					load sz
					call memcpy8
				end

				load livetip
				load sz
				i32.add
				tee livetip
				loadg heaptip
				i32.eq
				br_table 0 1
			end
		end

		load freetip
		i32 -8
		i32.and
		storeg heaptip
	end

export func gcmark
o i32 void
m i32
	; check liveness bit
	load o
	i32.load
	i32 1
	i32.and
	loadg bitmark
	i32.ne
	if
		load o
		loadg markbit
		i32.store

		block @vec
		block @table
			load o
			i32.load8_u 4
			br_table @gcmark @gcmark @gcmark @gcmark @table @gcmark @vec
		end ; @table
		load o
		i32.load 13
		call gcmark
		load o
		i32.load 17
		call gcmark
		load o
		i32.load 21
		call gcmark
		ret
		end ; @vec
		load o
		load o
		i32.load 5
		i32.add
		store m
		loop
			load o
			load m
			i32.eq
			br_if 1

			load o
			i32.load 9
			call gcmark

			load o
			i32 4
			i32.add
			store o

			br 0
		end
	end

export func tmppush
o i32 void
n i32 p i32
	loadg otmpstacklen
	loadg otmpstack
	i32.load 5
	i32.eq
	if
		load o
		storeg otmp

		loadg otmpstacklen
		loadg otmpstacklen
		i32.add
		tee n
		call newvec
		tee p

		load p
		loadg otmpstack
		loadg otmpstacklen
		i32 9
		i32.add
		call memcpy8

		storeg otmpstack

		load p
		load n
		i32.store 5

		loadg otmp
		store o
	end
	loadg otmpstack
	loadg otmpstacklen
	i32.add
	load o
	i32.store 9

	loadg otmpstacklen
	i32 4
	i32.add
	storeg otmpstacklen

export func tmppop
void
	loadg otmpstacklen
	i32 4
	i32.sub
	storeg otmpstacklen

	loadg otmpstack
	loadg otmpstacklen
	i32.add
	loadg onil
	i32.store 9

export func nthtmp
i i32 i32
	loadg otmpstack
	loadg otmpstacklen
	load i
	i32 2
	i32.shl
	i32.sub
	i32.add
	i32.load 9

export func setnthtmp
nv i32 i i32 void
	loadg otmpstack
	loadg otmpstacklen
	load i
	i32 2
	i32.shl
	i32.sub
	i32.add
	load nv
	i32.store 9

func gccollect
void
freetip i32 livetip i32 sz i32 n i32 m i32
	loadg markbit
	i32.eqz
	storeg markbit

	; Order follows init to avoid moving nil/false/true
	loadg onil
	call gcmark
	loadg ofalse
	call gcmark
	loadg otrue
	call gcmark
	loadg oroot
	call gcmark
	loadg otmp
	call gcmark
	loadg otmpstack
	call gcmark

	loadg oroot
	i32.load
	i32 -8
	i32.and
	storeg oroot

	loadg otmp
	i32.load
	i32 -8
	i32.and
	storeg otmp

	; Phase1 set reloc pointers
	loadg markbit
	store freetip

	block
	loop
		load livetip
		call sizeof
		store sz

		load livetip
		i32.load
		loadg markbit
		i32.eq
		if
			load livetip
			load freetip
			i32.store

			load freetip
			load sz
			i32.add
			store freetip
		end

		load livetip
		load sz
		i32.add
		tee livetip
		loadg heaptip
		i32.eq
		br_table 0 1
	end
	end

	; Phase2 fix reloc pointers
	i32 0
	store livetip
	block
	loop
		load livetip
		call sizeof 
		store sz

		load livetip
		i32.load
		i32 1
		i32.and
		loadg markbit
		i32.eq
		if
			block
			block
			block
			block
			block
			block
			block
				load livetip
				i32.load8_u 4
				br_table 0 1 2 3 4 5 6
			end ;0 i64
			ret
			end ;1 f64
			ret
			end ;2 nil
			ret
			end ;3 bool
			ret
			end ;4 table
			load livetip
			load livetip
			i32.load 13
			i32.load
			i32 -8
			i32.and
			i32.store 13
			load livetip
			load livetip
			i32.load 17
			i32.load
			i32 -8
			i32.and
			i32.store 17
			load livetip
			load livetip
			i32.load 21
			i32.load
			i32 -8
			i32.and
			i32.store 21
			end ;5 str
			ret
			end ;6 vec
			load livetip
			tee n
			load livetip
			i32.load 5
			i32.add
			store m
			loop
				load n
				load m
				i32.eq
				br_if 1

				load n
				load n
				i32.load 9
				i32.load
				i32 -8
				i32.and
				i32.store 9

				load n
				i32 4
				i32.add
				store n

				br 0
			end
		end

		load livetip
		load sz
		i32.add
		tee livetip
		loadg heaptip
		i32.eq
		br_table 0 1
	end
	end

	call gcfix

	; Phase3 move it
	i32 0
	store livetip
	block
		block
		loop
			load livetip
			call sizeof
			store sz

			load livetip
			load livetip
			i32.load
			i32 -8
			i32.and
			tee n
			i32.ne
			br_if 1

			load livetip
			load sz
			i32.add
			tee livetip
			loadg heaptip
			i32.eq
			br_table 0 2
		end
		end

		load livetip
		load n
		load sz
		call memcpy8

		load livetip
		load sz
		i32.add
		tee livetip
		loadg heaptip
		i32.ne
		if
			loop
				load livetip
				call sizeof
				store sz

				load livetip
				load livetip
				i32.load
				i32 -8
				i32.and
				load sz
				call memcpy8

				load livetip
				load sz
				i32.add
				tee livetip
				loadg heaptip
				i32.eq
				br_table 0 1
			end
		end

		load freetip
		i32 -8
		i32.and
		storeg heaptip
	end

func gcmark
o i32 void
m i32
	; check liveness bit
	load o
	i32.load
	i32 1
	i32.and
	loadg bitmark
	i32.ne
	if
		load o
		loadg markbit
		i32.store

		block
		block
		block
		block
		block
		block
		block
			load o
			i32.load8_u 4
			br_table 0 1 2 3 4 5 6
		end ;0 i64
		ret
		end ;1 f64
		ret
		end ;2 nil
		ret
		end ;3 bool
		ret
		end ;4 table
		load o
		i32.load 13
		call gcmark
		load o
		i32.load 17
		call gcmark
		load o
		i32.load 21
		call gcmark
		end ;5 str
		ret
		end ;6 vec
		load o
		load o
		i32.load 5
		i32.add
		store m
		loop
			load o
			load m
			i32.eq
			br_if 1

			load o
			i32.load 9
			call gcmark

			load o
			i32 4
			i32.add
			store o

			br 0
		end
	end

export func addroot
o i32 i32
n i32
	load o
	storeg otmp
	loadg oroot
	i32.load 5
	tee n
	i32 4
	i32.add
	call newvec
	tee p

	load p
	loadg oroot
	load n
	i32 9
	i32.add
	call memcpy8

	storeg oroot

	load p
	load n
	i32.add
	loadg otmp
	i32.store 9

	load p
	load n
	i32 4
	i32.add
	i32.store 5

	loadg otmp

export func rmroot
o i32 void
n i32 m i32 p i32
	load o
	storeg otmp

	loadg oroot
	i32.load 5
	i32 1
	i32.sub
	tee m
	call newvec
	store p

	loadg otmp
	store o

	loadg oroot
	tee n
	load m
	i32.add
	store m

	loop
		load n
		load m
		i32.eq
		br_if 1

		load n
		i32.load
		load o
		i32.ne
		if
			load p
			load n
			i32.load
			i32.store

			load p
			i32 4
			i32.add
			store p
		end

		load n
		i32 4
		i32.add
		store n

		br 0
	end

func tmppush
o i32 void
n i32 p i32
	loadg otmpstacklen
	loadg otmpstack
	i32.load 5
	i32.eq
	if
		loadg otmpstacklen
		loadg otmpstacklen
		i32.add
		tee n
		call newvec
		tee p

		load p
		loadg otmpstack
		load n
		i32 9
		i32.add
		call memcpy8

		storeg otmpstack

		load p
		load n
		i32.store 5
	end
	loadg otmpstack
	loadg otmpstacklen
	i32.add
	load o
	i32.store 5

	loadg otmpstacklen
	i32 4
	i32.add
	storeg otmpstacklen

func tmppop
void
	loadg otmpstacklen
	i32 4
	i32.sub
	storeg otmpstacklen

	loadg otmpstack
	loadg otmpstacklen
	i32.add
	loadg onil
	i32.store

func nthtmp
i i32 i32
	loadg otmpstack
	loadg otmpstacklen
	load i
	i32.sub
	i32.add
	i32.load 5

/* reuse this for table.remove
export func rmroot
o i32 void
p i32 q i32
	loadg oroot
	loadg oroot
	i32.load 5
	i32.add
	tee q
	store p
	loop
		load p
		i32 4
		i32.sub
		tee p
		i32.load
		load o
		i32.eq
		if
			loop
				load p
				load p
				i32 4
				i32.add
				tee p
				i32.load
				i32.store

				load p
				load q
				i32.eq
				if
					load p
					i32 4
					i32.sub
					loadg onil
					i32.store
					ret
				end

				br 0
			end
		end
		br 0
	end
*/

func gccollect
void
freetip i32 livetip i32 sz i32 n i32 m i32
	loadg markbit
	i32.eqz
	storeg markbit

	; Order follows init to avoid moving nil/false/true
	loadg onil
	call gcmark
	loadg ofalse
	call gcmark
	loadg otrue
	call gcmark
	loadg oroot
	call gcmark
	loadg otmp
	call gcmark
	loadg otmpstack
	call gcmark

	; Phase1 set reloc pointers
	loadg markbit
	store freetip

	block
	loop
		load livetip
		call sizeof
		store sz

		load livetip
		i32.load
		loadg markbit
		i32.eq
		if
			load livetip
			load freetip
			i32.store

			load freetip
			load sz
			i32.add
			store freetip
		end

		load livetip
		load sz
		i32.add
		tee livetip
		loadg heaptip
		i32.eq
		br_table 0 1
	end
	end

	; Phase2 fix reloc pointers
	loadg oroot
	i32.load
	i32 -8
	i32.and
	storeg oroot

	loadg otmp
	i32.load
	i32 -8
	i32.and
	storeg otmp

	loadg otmpstack
	i32.load
	i32 -8
	i32.and
	storeg otmpstack

	i32 0
	store livetip
	block
	loop
		load livetip
		call sizeof 
		store sz

		load livetip
		i32.load
		i32 1
		i32.and
		loadg markbit
		i32.eq
		if @terminal
			block @vec
			block @table
				load livetip
				i32.load8_u 4
				br_table @terminal @terminal @terminal @terminal @table @terminal @vec
			end ; @table
			load livetip
			load livetip
			i32.load 13
			i32.load
			i32 -8
			i32.and
			i32.store 13
			load livetip
			load livetip
			i32.load 17
			i32.load
			i32 -8
			i32.and
			i32.store 17
			load livetip
			load livetip
			i32.load 21
			i32.load
			i32 -8
			i32.and
			i32.store 21
			end ; @vec
			load livetip
			tee n
			load livetip
			i32.load 5
			i32.add
			store m
			loop
				load n
				load m
				i32.eq
				br_if 1

				load n
				load n
				i32.load 9
				i32.load
				i32 -8
				i32.and
				i32.store 9

				load n
				i32 4
				i32.add
				store n

				br 0
			end
		end

		load livetip
		load sz
		i32.add
		tee livetip
		loadg heaptip
		i32.eq
		br_table 0 1
	end
	end

	call .gcfix

	; Phase3 move it
	i32 0
	store livetip
	block
		block @foundshift
		loop
			load livetip
			call sizeof
			store sz

			load livetip
			i32.load
			i32 1
			i32.and
			loadg markbit
			i32.eq
			if
				load livetip
				load livetip
				i32.load
				i32 -8
				i32.and
				tee n
				i32.ne
				br_if @foundshift
			end

			load livetip
			load sz
			i32.add
			tee livetip
			loadg heaptip
			i32.eq
			br_table 0 2
		end
		end

		load n
		load livetip
		load sz
		call memcpy8

		load livetip
		load sz
		i32.add
		tee livetip
		loadg heaptip
		i32.ne
		if
			loop
				load livetip
				call sizeof
				store sz

				load livetip
				i32.load
				i32 1
				i32.and
				loadg markbit
				i32.eq
				if
					load livetip
					i32.load
					i32 -8
					i32.and
					load livetip
					load sz
					call memcpy8
				end

				load livetip
				load sz
				i32.add
				tee livetip
				loadg heaptip
				i32.eq
				br_table 0 1
			end
		end

		load freetip
		i32 -8
		i32.and
		storeg heaptip
	end

func gcmark
o i32 void
m i32
	; check liveness bit
	load o
	i32.load
	i32 1
	i32.and
	loadg bitmark
	i32.ne
	if
		load o
		loadg markbit
		i32.store

		block @vec
		block @table
			load o
			i32.load8_u 4
			br_table @gcmark @gcmark @gcmark @gcmark @table @gcmark @vec
		end ; @table
		load o
		i32.load 13
		call gcmark
		load o
		i32.load 17
		call gcmark
		load o
		i32.load 21
		call gcmark
		ret
		end ; @vec
		load o
		load o
		i32.load 5
		i32.add
		store m
		loop
			load o
			load m
			i32.eq
			br_if 1

			load o
			i32.load 9
			call gcmark

			load o
			i32 4
			i32.add
			store o

			br 0
		end
	end

export func addroot
o i32 i32
n i32
	load o
	storeg otmp
	loadg oroot
	i32.load 5
	tee n
	i32 4
	i32.add
	call newvec
	tee p

	load p
	loadg oroot
	load n
	i32 9
	i32.add
	call memcpy8

	storeg oroot

	load p
	load n
	i32.add
	loadg otmp
	i32.store 9

	load p
	load n
	i32 4
	i32.add
	i32.store 5

	loadg otmp

export func rmroot
o i32 void
n i32 m i32 p i32
	load o
	storeg otmp

	loadg oroot
	i32.load 5
	i32 4
	i32.sub
	tee m
	call newvec
	loadg oroot
	tee n
	load m
	i32.add
	store m
	tee p
	storeg oroot

	loadg otmp
	store o

	loop
		load n
		load m
		i32.eq
		br_if 1

		load n
		i32.load 9
		load o
		i32.ne
		if
			load p
			load n
			i32.load 9
			i32.store 9

			load p
			i32 4
			i32.add
			store p
		end

		load n
		i32 4
		i32.add
		store n

		br 0
	end

func tmppush
o i32 void
n i32 p i32
	loadg otmpstacklen
	loadg otmpstack
	i32.load 5
	i32.eq
	if
		load o
		storeg otmp

		loadg otmpstacklen
		loadg otmpstacklen
		i32.add
		tee n
		call newvec
		tee p

		load p
		loadg otmpstack
		load n
		i32 9
		i32.add
		call memcpy8

		storeg otmpstack

		load p
		load n
		i32.store 5

		loadg otmp
		store o
	end
	loadg otmpstack
	loadg otmpstacklen
	i32.add
	load o
	i32.store 9

	loadg otmpstacklen
	i32 4
	i32.add
	storeg otmpstacklen

func tmppop
void
	loadg otmpstacklen
	i32 4
	i32.sub
	storeg otmpstacklen

	loadg otmpstack
	loadg otmpstacklen
	i32.add
	loadg onil
	i32.store

func nthtmp
i i32 i32
	loadg otmpstack
	loadg otmpstacklen
	load i
	i32 2
	i32.shl
	i32.sub
	i32.add
	i32.load 9

/* reuse this for table.remove
export func rmroot
o i32 void
p i32 q i32
	loadg oroot
	loadg oroot
	i32.load 5
	i32.add
	tee q
	store p
	loop
		load p
		i32 4
		i32.sub
		tee p
		i32.load
		load o
		i32.eq
		if
			loop
				load p
				load p
				i32 4
				i32.add
				tee p
				i32.load
				i32.store

				load p
				load q
				i32.eq
				if
					load p
					i32 4
					i32.sub
					loadg onil
					i32.store
					ret
				end

				br 0
			end
		end
		br 0
	end
*/

/*
Header:
i32 ref
i8 type
*/

use alloc
global mut i32 onil
global mut i32 otrue
global mut i32 ofalse

func incref
x i32 i32
	load x
	i32.load
	i32 1
	i32.add
	load x
	i32.store
	load x
	ret

func decref
x i32 void
y i32
	load x
	i32.load
	i32 1
	i32.sub
	tee y
	if
		load x
		load y
		i32.store
	else
		load x
		call free
	end

func newi64
x i64 i32
p i32
	i32 13
	call malloc
	tee p
	i32 1
	i32.store
	loadl p
	i32 0
	i32.store8 4
	loadl p
	loadl x
	i64.store 5
	load p
	ret

func newf64
x f64 i32
p i32
	i32 13
	call malloc
	tee p
	i32 1
	i32.store
	loadl p
	i32 1
	i32.store8 4
	loadl p
	loadl x
	f64.store 5
	load p
	ret

func newstr
sz i32
p i32
	i32 13
	load sz
	i32.add
	call malloc
	tee p
	i32 1
	i32.store
	load p
	i32 5
	i32.store8 4
	load p
	i32 sz
	i32.store 5
	load p
	i32 0
	i32.store 9
	load p
	ret

func istrue
x i32 i32
	load x
	loadg onil
	i32.eq
	load x
	loadg ofalse
	i32.eq
	i32.or
	ret

func eq
a i32 b i32 i32
i i32
	load a
	i32.load8_u 4
	load b
	i32.load8_u 4
	i32.ne
	if
		i32 0
		ret
	end
	block
	block
	block
	block
	block
	load a
	i32.load8_u 4
	br_table 0 1 2 3 4 5
	end ;0 i64
	load a
	i64.load 5
	load b
	i64.load 5
	i64.eq
	ret
	end ;1 f64
	load a
	f64.load 5
	load b
	f64.load 5
	f64.eq
	ret
	end ;2 nil
	i32 1
	ret
	end ;3 bool
	load a
	load b
	i32.eq
	ret
	end ;4 table
	load a
	load b
	i32.eq
	ret
	end ;5 string
	load a
	load b
	i32.eq
	if
		i32 1
		ret
	end
	load a
	i32.load 5
	tee i
	load b
	i32.load 5
	i32.ne
	if
		i32 0
		ret
	end
	load a
	i32 13
	i32.add
	store a
	load b
	i32 13
	i32.add
	store b
	loop
		load i
		if
			load a
			load i
			i32.add
			i32.load8_u
			load b
			load i
			i32.add
			i32.load8_u
			i32.ne
			if
				i32 0
				ret
			end
		else
			load a
			i32.load8_u
			load b
			i32.load8_u
			i32.eq
			ret
		end
	end

global i32 heaptip
global i32 markbit
global i32 onil
global i32 otrue
global i32 ofalse
global i32 oroot
global i32 otmp

func allocsize
sz i32 i32
	load sz
	i32 7
	i32.and
	if i32
		load sz
		i32 -8
		i32.and
		i32 8
		i32.add
	else
		load sz
	end

func newobj
sz i32 t i32 i32
p i32 ht i32
	loadg heaptip
	tee p
	load sz
	i32.add
	tee ht
	i32 16
	i32.shr_u
	current_memory
	i32.ge_u
	if
		call gccollect

		loadg heaptip
		tee p
		load sz
		i32.add
		storeg heaptip
		loadg heaptip
		i32 16
		i32.shr_u
		tee sz
		current_memory
		i32.ge_u
		if
			load sz
			current_memory
			i32.sub
			i32 1
			i32.add
			grow_memory
			drop
		end
	else
		load ht
		storeg heaptip
	end
	; store header to p
	load p
	loadg markbit
	i32.store
	load p
	load t
	i32.store8 4
	load p

export func newi64
x i64 i32
p i32
	i32 16
	i32 0
	call newobj
	tee p
	load x
	i64.store 5
	load p

export func newf64
x f64 i32
p i32
	i32 16
	i32 1
	call newobj
	tee p
	load x
	f64.store 5
	load p

export func newtable
i32
p i32
	i32 32
	i32 4
	call newobj
	storeg otmp

	; len, hlen = 0
	loadg otmp
	i64 0
	i64.store 5

	loadg otmp ; arr, hash = nil
	loadg onilnil64
	i64.store 13

	loadg otmp ; meta = nil
	loadg onil
	i32.store 21

	loadg otmp ; arr = newvec(4*4)
	i32 16
	call newvec
	i32.store 13

	loadg otmp ; hash = newvec(4*8)
	i32 32
	call newvec
	i32.store 17

	loadg otmp

export func newstr
sz i32 i32
p i32 psz i32
	i32 13
	load sz
	i32.add
	call allocsize
	i32 5
	call newobj
	tee p
	load sz
	i32.store 5
	load p
	i32 0
	i32.store 9

	load p
	load sz
	i32.add
	store psz

	block
		block
			block
				block
					block
						block
							block
								block
									load sz
									i32 7
									i32.and
									br_table 4 5 6 7 0 1 2 3
								end ;0
								load psz
								i32 0
								i32.store 13
								load psz
								i32 0
								i32.store16 17
								load psz
								i32 0
								i32.store8 19
								br 6
							end ;1
							load psz
							i32 0
							i32.store 13
							load psz
							i32 0
							i32.store16 17
							br 5
						end ;2
						load psz
						i32 0
						i32.store 13
						load psz
						i32 0
						i32.store8 17
						br 4
					end ;3
					load psz
					i32 0
					i32.store 13
					br 3
				end ;4
				load psz
				i32 0
				i32.store16 13
				load psz
				i32 0
				i32.store8 15
				br 2
			end ;5
			load psz
			i32 0
			i32.store16 13
			br 1
		end ;6
		load psz
		i32 0
		i32.store8 13
	end ;7
	load p

/*
struct Vec {
	00 i32
	04 i8 type6
	05 i32 len
	09 ...
}
*/
export func newvec
sz i32 i32
p i32 n i32
	i32 9
	load sz
	i32.add
	call allocsize
	i32 6
	call newobj
	tee p
	load sz
	i32.store 5

	; need to start with (sz - n)%8 == 0
	load sz
	i32 4
	i32.and
	if
		load p
		loadg onil
		i32.store 9
		i32 4
		store n
	end

	loop ; fill vec with references to nil
		load p
		load n
		load sz
		i32.eq
		br_if 1
		load n
		i32.add
		loadg onilnil64
		i64.store 9

		load n
		i32 8
		i32.add
		store n
		br 0
	end
	unreachable

func istrue
x i32 i32
	load x
	loadg onil
	i32.eq
	load x
	loadg ofalse
	i32.eq
	i32.or

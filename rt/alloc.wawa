global i32 heap_tip
global i32 onil
global i32 otrue
global i32 ofalse
global i32 oroot
global i32 markbit

func allocsize
sz i32 i32
	load sz
	i32 7
	i32.and
	if i32
		load sz
		i32 -8
		i32.and
		i32 8
		i32.add
	else
		load sz
	end
	ret

func newobj
sz i32 t i32 i32
p i32
	loadg heap_tip
	tee p
	loadg heap_tip
	load sz
	i32.add
	storeg heap_tip
	loadg heap_tip
	i32 16
	i32.shr_u
	i32 1
	i32.add
	current_memory
	i32.sub
	tee sz
	if
		load sz
		grow_memory
		drop
	end
	; store header to p
	loadg markbit
	i32.store
	load p
	load t
	i32.store8 4
	load p
	ret

export func newi64
x i64 i32
p i32
	i32 16
	i32 0
	call newobj
	tee p
	load x
	i64.store 5
	load p
	ret

export func newf64
x f64 i32
p i32
	i32 16
	i32 1
	call newobj
	tee p
	load x
	f64.store 5
	load p
	ret

export func newtable
i32
p i32
	i32 32
	i32 4
	call newobj
	tee p

	; len = 0, hlen = 0
	i64 0
	i64.store 5

	load p ; arr = newvec(4*4)
	i32 16
	call newvec
	i32.store 13

	load p ; hash = newvec(4*8)
	i32 32
	call newvec
	i32.store 17

	load p ; meta = nil
	loadg onil
	i32.store 21
	load p
	ret

export func newstr
sz i32 i32
p i32 psz i32
	i32 13
	load sz
	i32.add
	call allocsize
	i32 5
	call newobj
	tee p
	load sz
	i32.store 5
	load p
	i32 0
	i32.store 9

	load p
	load sz
	i32.add
	store psz

	block
		block
			block
				block
					block
						block
							block
								block
									load sz
									i32 7
									i32.and
									br_table 7 6 5 4 3 2 1 0
								end
								load psz
								i32 0
								i32.store 13
								load psz
								i32 0
								i32.store16 17
								load psz
								i32 0
								i32.store8 19
								br 6
							end
							load psz
							i32 0
							i32.store 13
							load psz
							i32 0
							i32.store16 17
							br 5
						end
						load psz
						i32 0
						i32.store 13
						load psz
						i32 0
						i32.store8 17
						br 4
					end
					load psz
					i32 0
					i32.store 13
					br 3
				end
				load psz
				i32 0
				i32.store16 13
				load psz
				i32 0
				i32.store8 15
				br 2
			end
			load psz
			i32 0
			i32.store16 13
			br 1
		end
		load psz
		i32 0
		i32.store8 13
	end
	load p
	ret

/*
struct Vec {
	00 i32
	04 i8 type6
	05 i32 len
	13 ...
}
*/
export func newvec
sz i32 i32
p i32 n i32
	i32 9
	load sz
	i32.add
	call allocsize
	i32 6
	call newobj
	tee p
	load sz
	i32.store 5

	; need to start with (sz - n)%8 == 0
	load sz
	i32 4
	i32.and
	if
		load p
		loadg onil
		i32.store 9
		i32 4
		store n
	end

	loop ; fill vec with references to nil
		load n
		load sz
		i32.eq
		if
			load p
			ret
		end
		load p
		load n
		i32.add
		loadg onilnil64
		i64.store 9

		load n
		i32 8
		i32.add
		store n
	end
	unreachable

func istrue
x i32 i32
	load x
	loadg onil
	i32.eq
	load x
	loadg ofalse
	i32.eq
	i32.or
	ret

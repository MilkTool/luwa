global i32 heap_tip
global i32 markbit
global i32 onil
global i32 otrue
global i32 ofalse
global i32 oroot
global i32 otmp

func allocsize
sz i32 i32
	load sz
	i32 7
	i32.and
	if i32
		load sz
		i32 -8
		i32.and
		i32 8
		i32.add
	else
		load sz
	end
	ret

func newobjnogc
sz i32 t i32 i32
p i32
	loadg heap_tip
	tee p
	loadg heap_tip
	load sz
	i32.add
	storeg heap_tip
	loadg heap_tip
	i32 16
	i32.shr_u
	i32 1
	i32.add
	current_memory
	i32.sub
	tee sz
	if
		load sz
		grow_memory
		drop
	end
	; store header to p
	loadg markbit
	i32.store
	load p
	load t
	i32.store8 4
	load p
	ret

func newobj
sz i32 t i32 i32
p i32 ht i32
	loadg heap_tip
	tee p
	load sz
	i32.add
	tee ht
	i32 16
	i32.shr_u
	current_memory
	i32.gt_u
	if i32
		call gccollect
		load sz
		load t
		call newobjnogc
	else
		load ht
		storeg ht
		load p
		loadg markbit
		i32.store
		load p
		load t
		i32.store8 4
		load p
	end
	ret

export func newi64
x i64 i32
p i32
	i32 16
	i32 0
	call newobj
	tee p
	load x
	i64.store 5
	load p
	ret

export func newf64
x f64 i32
p i32
	i32 16
	i32 1
	call newobj
	tee p
	load x
	f64.store 5
	load p
	ret

export func newtable
i32
p i32
	i32 32
	i32 4
	call newobj
	storeg otemp

	; len, hlen = 0
	loadg otmp
	i64 0
	i64.store 5

	loadg otmp ; arr, hash = nil
	loadg onilnil64
	i64.store 13

	loadg otmp ; meta = nil
	loadg onil
	i32.store 21

	loadg otmp ; arr = newvec(4*4)
	i32 16
	call newvec
	i32.store 13

	loadg otmp ; hash = newvec(4*8)
	i32 32
	call newvec
	i32.store 17

	loadg otmp
	ret

export func newstr
sz i32 i32
p i32 psz i32
	i32 13
	load sz
	i32.add
	call allocsize
	i32 5
	call newobj
	tee p
	load sz
	i32.store 5
	load p
	i32 0
	i32.store 9

	load p
	load sz
	i32.add
	store psz

	block
		block
			block
				block
					block
						block
							block
								block
									load sz
									i32 7
									i32.and
									br_table 4 5 6 7 0 1 2 3
								end ;0
								load psz
								i32 0
								i32.store 13
								load psz
								i32 0
								i32.store16 17
								load psz
								i32 0
								i32.store8 19
								br 6
							end ;1
							load psz
							i32 0
							i32.store 13
							load psz
							i32 0
							i32.store16 17
							br 5
						end ;2
						load psz
						i32 0
						i32.store 13
						load psz
						i32 0
						i32.store8 17
						br 4
					end ;3
					load psz
					i32 0
					i32.store 13
					br 3
				end ;4
				load psz
				i32 0
				i32.store16 13
				load psz
				i32 0
				i32.store8 15
				br 2
			end ;5
			load psz
			i32 0
			i32.store16 13
			br 1
		end ;6
		load psz
		i32 0
		i32.store8 13
	end ;7
	load p
	ret

/*
struct Vec {
	00 i32
	04 i8 type6
	05 i32 len
	09 ...
}
*/
export func newvec
sz i32 i32
p i32 n i32
	i32 9
	load sz
	i32.add
	call allocsize
	i32 6
	call newobj
	tee p
	load sz
	i32.store 5

	; need to start with (sz - n)%8 == 0
	load sz
	i32 4
	i32.and
	if
		load p
		loadg onil
		i32.store 9
		i32 4
		store n
	end

	loop ; fill vec with references to nil
		load n
		load sz
		i32.eq
		if
			load p
			ret
		end
		load p
		load n
		i32.add
		loadg onilnil64
		i64.store 9

		load n
		i32 8
		i32.add
		store n
	end
	unreachable

func istrue
x i32 i32
	load x
	loadg onil
	i32.eq
	load x
	loadg ofalse
	i32.eq
	i32.or
	ret
